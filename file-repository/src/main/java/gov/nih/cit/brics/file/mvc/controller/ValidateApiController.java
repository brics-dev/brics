package gov.nih.cit.brics.file.mvc.controller;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.NoSuchElementException;
import java.util.zip.CRC32;

import org.apache.commons.codec.digest.DigestUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.context.annotation.RequestScope;

import gov.nih.cit.brics.file.data.repository.meta.BricsFileRepository;
import gov.nih.cit.brics.file.exception.LegacyFileAccessException;
import gov.nih.cit.brics.file.mvc.controller.swagger.ValidateApi;
import gov.nih.cit.brics.file.mvc.model.swagger.ValidationResult;
import gov.nih.cit.brics.file.service.FileRepositoryService;
import gov.nih.tbi.file.model.hibernate.BricsFile;

@RestController
@RequestScope
public class ValidateApiController extends BaseFileRestController implements ValidateApi {
	private static final Logger logger = LoggerFactory.getLogger(ValidateApiController.class);

	@Autowired
	private BricsFileRepository bricsFileRepository;

	@Autowired
	private FileRepositoryService fileRepositoryService;

	/**
	 * Calculates the CRC value of the system file referenced by the given file ID.
	 * 
	 * @param fileId - The ID of the referenced file that will need a CRC value calculated.
	 * @param clientCrc - The CRC value from the client that will need to be compared with the calculated CRC value.
	 * 
	 * @return A response with a ValidationResult entity containing the result of the comparison of the two CRC values,
	 *         and the CRC values themselves.
	 */
	@Override
	public ResponseEntity<ValidationResult> checkCrcValue(String fileId, String clientCrc) {
		String calcCrc = null;

		try {
			BricsFile bricsFile = bricsFileRepository.findById(fileId).get();

			// Check permissions to the file before continuing.
			if (checkUserPermissions(bricsFile)) {
				File sysFile = fileRepositoryService.getSystemFile(bricsFile);
				CRC32 crcGen = new CRC32();
				byte[] buffer = new byte[4096];
				int bytesRead = -1;
				FileInputStream in = new FileInputStream(sysFile);

				// Calculate the CRC for the referenced file.
				try {
					bytesRead = in.read(buffer);

					while (bytesRead > 0) {
						crcGen.update(buffer, 0, bytesRead);
						bytesRead = in.read(buffer);
					}

					calcCrc = Long.toString(crcGen.getValue());
					logger.info("Computed the CRC value of {} for the \"{}\" file on the server.", calcCrc,
							bricsFile.getFileName());
				} finally {
					in.close();
				}
			} else {
				logger.error("The {} user cannot access BricsFile {}.", getAccount().getUserName(),
						bricsFile.getId());
				return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
			}
		} catch (NoSuchElementException e) {
			logger.error("The given file ID of \"{}\" cannot be found in the database.", fileId);

			return ResponseEntity.notFound().build();
		} catch (FileNotFoundException e) {
			logger.error("The file referenced by \"" + fileId + "\" doesn't exist in the file system.", e);

			return ResponseEntity.notFound().build();
		} catch (IOException e) {
			logger.error("Error when reading the system file.", e);

			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
		} catch (LegacyFileAccessException e) {
			logger.error("Error occurred when accessing the legacy file from the data drop share.", e);
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
		}

		// Create the response.
		ValidationResult response = new ValidationResult();
		response.setIsHashValid(Boolean.valueOf(clientCrc.equals(calcCrc)));
		response.setGeneratedHash(calcCrc);
		response.setProvidedHash(clientCrc);

		return ResponseEntity.ok(response);
	}

	/**
	 * Calculates the MD5 hash of the file referenced by the given file ID.
	 * 
	 * @param fileId - The ID of the file which will be used to generate the MD5 hash.
	 * @param clientHash - The MD5 hash generated by the client, which will be compared with the newly generated hash.
	 * @return A response with a ValidationResult entity containing the result of the comparison of the two MD5 hashes,
	 *         as well as the hashes themselves.
	 */
	@Override
	public ResponseEntity<ValidationResult> checkMd5Hash(String fileId, String clientHash) {
		String md5Hash = null;

		try {
			BricsFile bricsFile = bricsFileRepository.findById(fileId).get();

			// Check permissions to the file before continuing.
			if (checkUserPermissions(bricsFile)) {
				File sysFile = fileRepositoryService.getSystemFile(bricsFile);

				// Create the MD5 hash.
				md5Hash = DigestUtils.md5Hex(new FileInputStream(sysFile));
				logger.info("Computed the MD5 hash for the \"{}\" file to be: {}.", bricsFile.getFileName(), md5Hash);
			} else {
				logger.error("The {} user cannot access the BricsFile {}.", getAccount().getUserName(),
						bricsFile.getId());
				return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
			}
		} catch (NoSuchElementException e) {
			logger.error("The given file ID of \"{}\" cannot be found in the database.", fileId);

			return ResponseEntity.notFound().build();
		} catch (FileNotFoundException e) {
			logger.error("The file referenced by \"" + fileId + "\" doesn't exist in the file system.", e);

			return ResponseEntity.notFound().build();
		} catch (IOException e) {
			logger.error("Error when reading the system file.", e);

			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
		} catch (LegacyFileAccessException e) {
			logger.error("Error occurred when accessing the legacy file from the data drop share.", e);
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
		}

		// Create the response entity.
		ValidationResult response = new ValidationResult();
		response.setIsHashValid(Boolean.valueOf(md5Hash.equals(clientHash)));
		response.setGeneratedHash(md5Hash);
		response.setProvidedHash(clientHash);

		return ResponseEntity.ok(response);
	}

}
